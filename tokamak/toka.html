<!DOCTYPE HTML>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>IPPEX</title>
    <link rel="stylesheet" href="./toka.css">
    <link rel="stylesheet" href="../bower_components/katex/dist/katex.min.css">
    <script src="../bower_components/katex/dist/katex.min.js"></script>
    <script src="../bower_components/jquery/dist/jquery.min.js"></script>
    <script src="../bower_components/pixi/bin/pixi.min.js"></script>
    <script src="../bower_components/pixi/bin/pixi.min.js"></script>
    <script src="../bower_components/dat.gui/dat.gui.js"></script>
    <script src="../bower_components/stats.js/build/stats.min.js"></script>
</head>

<body>
<div id="title" class="title" style="position: absolute; top: 10px; left: 100px;'">
    <!-- <i class="fa fa-globe fa-inverse fa-3x"></i> -->
    <input type="text" id="status" class="console"></input>
    <textarea type="text" id="console" class="console"></textarea>
</div>
<div id="score" class="title" style="position: absolute; top: 550px; left: 100px;'">
SCORE: 0
</div>
<div id="temperatureDiv" class="title" style="position: absolute; top: 600px; left: 100px; color: #89ff8f;'">
<!-- TEMPERATURE: 0 -->
<input type="text" id="temperature" class="console temperature"></input>
</div>
<div id="container"></div>
<!-- <script src="../libs/util/dat.gui.min.js"></script> -->
<script src="../libs/util/TweenMax.min.js"></script>
<!-- <script src="../libs/jquery/jquery.min.js"></script> -->
<!-- <script src="../libs/pixi/pixi.min.js"></script> -->
<!-- // <script src="../libs/jquery-mobile/jquery.mobile-1.4.5.min.js"></script> -->
<script src="../libs/kinematica/ui.js"></script>
<script src="toka_physics.js"></script>
<script defer="defer">

//==============================================================================
//                                  START
//==============================================================================

var Params = function() {
  this.scale = 1;
  this.tscale = 4;
  // this.T = 10000;
  this.B = 1;
  this.Dens = 2.5;
  this.Pow = 0.19;
  this.highlightFieldLine = false;
  this.highlightBatch = false;
  this.showFieldLine = function() { g.visible = !(g.visible); };
};

var Torus = {R:300, r:200};
var Plasma = {v: 1, wSpread: 0.5/1000, T: 10000};
var params = new Params();
var gui = new dat.GUI();
gui.add(params, 'scale', 0.1, 5);
gui.add(params, 'tscale', 1, 10);
// gui.add(params, 'T', 1000, 1000);
gui.add(params, 'B', 1, 14);
gui.add(params, 'Dens', 0, 10);
gui.add(params, 'Pow', 0, 10);
gui.add(params, 'highlightFieldLine');
gui.add(params, 'highlightBatch');
gui.add(params, 'showFieldLine');

function getRandomReal(min, max) {
  return Math.random() * (max - min + 1) + min;
}
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function plasmaPath(arg, phase){
        // return (0.5 + 0.5 * Math.pow((Math.sin(2*arg), 2)));
        // return Math.pow(arg, 2);
        // return 0.5 + 0.5 * Math.pow(Math.sin(2 * (arg + phase)), 2);
        return 0.5 + 0.5 * Math.pow(Math.sin((arg + phase)/q), 2);  //R between 0.5 and 1
}
function plasmaPathScale(arg, phase){
        // return (0.5 + 0.5 * Math.pow((Math.sin(2*arg), 2)));
        // return Math.pow(arg, 2);
        // return 0.5 + 0.5 * Math.pow(Math.sin(2 * (arg + phase)), 2);
        return 0.4 + 0.6 * Math.pow(Math.sin((arg + phase +  Math.PI/2)/q), 2);
        // return 1;
}

function plasmaPathD(arg, phase){
        return Math.sin(2 * (arg + phase));
}

function plasmaPathN(arg, phase){
        return (plasmaPathD(arg, phase) * Math.sin(arg + phase) + plasmaPath(arg, phase) * Math.cos(arg + phase))/(plasmaPathD(arg, phase) * Math.cos(arg + phase) - plasmaPath(arg, phase) * Math.sin(arg + phase));
}


//==============================================================================
//                                BUILD THE SCENE
//==============================================================================

var renderer = PIXI.autoDetectRenderer(width, height, {backgroundColor : 0x0e0e0e});
document.body.appendChild(renderer.view);

// create the root of the scene graph
var stage = new PIXI.Container();

// ///////////////////////////////////////////////////////////
// PIXI
// ///////////////////////////////////////////////////////////

// stage.position.x = renderer.width / 2;
// stage.position.y = renderer.height / 2;

// stage.interactive = true;

var container = new PIXI.Container();
container.position.x = renderer.width / 2;
container.position.y = renderer.height / 2;

var background = new PIXI.Container();
background.position.x = renderer.width / 2;
background.position.y = renderer.height / 2;

var underlay = new PIXI.Container();
underlay.position.x = renderer.width / 2;
underlay.position.y = renderer.height / 2;

var overlay = new PIXI.Container();
overlay.position.x = renderer.width / 2;
overlay.position.y = renderer.height / 2;

stage.addChild(background);
stage.addChild(underlay);
stage.addChild(container);
stage.addChild(overlay);

//IMAGE SOURCES
var sources = {
  spark: "img/spark5.png",
  reactor: "img/reactorBG5.png",
  coil: "img/coil5.png"
};

var images = {};
var g = new PIXI.Graphics();
var points = [];

//IMAGE LOADER (DO THIS FIRST BEFORE PROCESSING SCENE)
// function loadImages(sources, images, callback) {
//   var loadedImages = 0;
//   var numImages = 0;
//   // get num of sources
//   for(var src in sources) {
//     numImages++;
//   }
//   for(var src in sources) {
//     images[src] = new Image();
//     images[src].onload = function() {
//       if(++loadedImages >= numImages) {
//         callback();
//       }
//     };
//     images[src].src = sources[src];
//   }
// }

// //WHAT TO DO WITH THE LOADED IMAGES
// function draw(images) {
//   // image: images.gyro,
// }

// //LOAD ALL THE IMAGES AND CALL THE SCENE DRAWING FUNCTIONS WITH IT
// loadImages(sources, images, init);


// Main.prototype.loadSpriteSheet = function() {
//   var assetsToLoad = ["img/spark5.png", "img/reactorBG5.png", "img/coil5.png"];
//   loader = new PIXI.AssetLoader(assetsToLoad);
//   loader.onComplete = this.init.bind(this);
//   loader.load();
// };

// var assetsToLoad = ["img/spark5.png", "img/reactorBG5.png", "img/coil5.png"];
// var loader = new PIXI.Loader("img/spark5.png", 'true');
// loader.onLoaded = init.bind(this);
// loader.load();

var loader = PIXI.loader; // pixi exposes a premade instance for you to use.
// var loader = new PIXI.loaders.Loader(); // you can also create your own if you want
loader.add('spark',"img/spark5.png");
loader.add('reactor',"img/reactorBG5.png");
loader.add('coil',"img/coil5.png");
loader.once('complete',init);
loader.load();


function init(){

    // var texture_reactor = PIXI.TextureCache["img/reactorBG5.png"];
    // var texture_coil = PIXI.TextureCache["img/coil5.png"];
    // var texture_spark = PIXI.TextureCache["img/spark5.png"];
    // var texture_reactor = PIXI.TextureCache["img/spark5.png"];
    // var texture_coil = PIXI.TextureCache["img/spark5.png"];
    // Set up paths
    points = [];

    // for (var i = 0; i < fieldLines; i++) {
        var pointCurve = [];
        // var phase = 2 * Math.PI / fieldLines * i;
        var graphPoints = 1000;
        for (var j = 0; j < graphPoints; j++)
        {
            // var phi = Math.random() * 2 * Math.PI * ThetaMax;
            var phi = 2 * Math.PI * ThetaMax / graphPoints * j;
            var r = plasmaPath(phi, 0) * Torus.R;
            // pointCurve.push(new PIXI.Point(r * Math.cos(phi), r * Math.sin(phi)));
            // dude.scale.set(0.5 + 0.5 * Math.pow( Math.sin( (dude.phi + dude.phiStart - Math.PI/8) * 2), 2) );
            // dude.alpha = (0.2 + 0.8 * Math.pow( Math.sin( (dude.phi + dude.phiStart - Math.PI/8) * 2), 2) );
            // var size = Math.pow( Math.sin( (phi + phase - Math.PI/8) * 2), 2);
            var size = plasmaPathScale(phi, 0);
            pointCurve.push({x: r * Math.cos(phi), y: r * Math.sin(phi), size: size});
        }
        points.push(pointCurve);
    // }


    g = new PIXI.Graphics();
    g.x = 0;
    g.y = 0;
    underlay.addChild(g);
    // g.alpha = (0.1);
    g.visible = false;

    renderPoints();


    // holder to store the aliens

    for (var i = 0; i < totalDudes; i++)
    {
        // var angle = 2 * Math.PI / fieldLines * i;
        // angle %= 2 * Math.PI;
        var angle = Math.random() * 2 * Math.PI * ThetaMax;

        // create a new Sprite that uses the image name that we just generated as its source
        // var dude =  PIXI.Sprite.fromImage('spark3.png');
        // var dude =  PIXI.Sprite.fromImage(images.spark);
        // var dude =  PIXI.Sprite.fromFrame('img/spark5.png');
        var dude =  new PIXI.Sprite(loader.resources["spark"].texture);

        dude.group = (Math.cos(angle) > Math.cos(Math.PI/8)) ? 1 : 0;
        if (angle < 1 * Math.PI) dude.label = 'batch';

        // set the anchor point so the texture is centerd on the sprite
        dude.anchor.set(0.5);

        // set a random scale for the dude - no point them all being the same size!
        // dude.scale.set(1.4 + MatDh.random() * 0.3);
        dude.scale.set(1.5);

        // finally lets set the dude to be at a random position..
        dude.R = 0;
        dude.position.x = 0;
        dude.position.y = 0;
        dude.phi = 0;
        // dude.phiBias = 0;
        dude.phiRun = 0;
        dude.phiStart = angle;
        // dude.phiBias = rand;
        dude.displ = {};
        // dude.displ.x = (Math.random()-1) * 30;
        // dude.displ.y = (Math.random()-1) * 30;
        dude.displ.x = getRandomReal(-1,1) * ParticleSpread;
        dude.displ.y = getRandomReal(-1,1) * ParticleSpread;
        // dude.w = Plasma.w * (Math.random() > 0.5 ? 1 : -1) + Plasma.wSpread * Math.random();
        // dude.w = Plasma.v / dude.R;
        dude.w = Plasma.v / Torus.R;

        dude.oldPos = {};
        dude.oldPos.x = 0;
        dude.oldPos.y = 0;
        dude.newPos = {};
        dude.newPos.x = 0;
        dude.newPos.y = 0;
        dude.mPerp = 0;
        // dude.tint = Math.random() * 0xFFFFFF;
        // dude.tint = (0.7+Math.random() * 0.001) * 0xFFFFFF;
        // dude.PIXI.filters.BloomFilter(10);

        // create some extra properties that will control movement :
        // create a random direction in radians. This is a number between 0 and PI*2 which is the equivalent of 0 - 360 degrees
        // dude.direction = Math.random() * Math.PI * 2;

        // this number will be used to modify the direction of the dude over time
        // dude.turningSpeed = Math.random() - 0.8;

        // create a random speed for the dude between 0 - 2
        // dude.speed = (2 + Math.random() * 2)/10;


        // finally we push the dude into the aliens array so it it can be easily accessed later
        aliens.push(dude);

        container.addChild(dude);
    }

    // var bg = PIXI.Sprite.fromImage(images.reactor);
    var bg = new PIXI.Sprite(loader.resources["reactor"].texture);
    // bg.position = ({x:width/2, y:height/2});
    // bg.position.x = (width/2);
    // bg.offset.x = (width/2);
    bg.anchor.set(0.5);
    bg.scale.set(1.12,1.12);
    background.addChild(bg);
    bg.zIndex = 2;

    // var coil1 = PIXI.Sprite.fromImage(texture_coil);
    var coil1 = new PIXI.Sprite(loader.resources["coil"].texture);
    coil1.position = ({x:-0.75*Torus.R*Math.cos(Math.PI/4), y:-0.75*Torus.R*Math.cos(Math.PI/4)});
    coil1.anchor.set(0.5);
    coil1.scale.set(0.5,0.5);
    coil1.rotation = (Math.PI/4);
    overlay.addChild(coil1);

    // var coil2 = new PIXI.Sprite.fromImage(texture_coil);
    var coil2 = new PIXI.Sprite(loader.resources["coil"].texture);
    coil2.position = ({x:0.75*Torus.R*Math.cos(Math.PI/4), y:-0.75*Torus.R*Math.cos(Math.PI/4)});
    coil2.anchor.set(0.5);
    coil2.scale.set(0.5,0.5);
    coil2.rotation = (-Math.PI/4);
    overlay.addChild(coil2);

    // var coil3 = new PIXI.Sprite.fromImage('img/spark5.png');
    var coil3 = new PIXI.Sprite(loader.resources["coil"].texture);
    coil3.position = ({x:0.75*Torus.R*Math.cos(Math.PI/4), y:0.75*Torus.R*Math.cos(Math.PI/4)});
    coil3.anchor.set(0.5);
    coil3.scale.set(0.5,0.5);
    coil3.rotation = (Math.PI/4);
    overlay.addChild(coil3);

    // var coil4 = new PIXI.Sprite.fromImage('img/spark5.png');
    var coil4 = new PIXI.Sprite(loader.resources["coil"].texture);
    coil4.position = ({x:-0.75*Torus.R*Math.cos(Math.PI/4), y:0.75*Torus.R*Math.cos(Math.PI/4)});
    coil4.anchor.set(0.5);
    coil4.scale.set(0.5,0.5);
    coil4.rotation = (-Math.PI/4);
    overlay.addChild(coil4);


    // var colorMatrix =  [
    //     1,0,0,0.5,
    //     0,1,0,0.5,
    //     0,0,1,0.5,
    //     0,0,0,1
    // ];
    // var filter = new PIXI.filters.ColorMatrixFilter();
    // filter.matrix = colorMatrix;
    // stage.filters = [filter];

    // var blurFilter1 = new PIXI.filters.BlurFilter();
    // var blurFilter1 = new  PIXI.filters.InvertFilter()
    var blurFilter1 = new PIXI.filters.BloomFilter();
    // var blurFilter1 = new PIXI.filters.GrayFilter();
    // var blurFilter1 = new PIXI.filters.PixelateFilter();
    // var blurFilter1 = new PIXI.filters.TwistFilter();
    // var blurFilter1 = new PIXI.filters.NoiseFilter();
    // var blurFilter1 = new PIXI.filters.DropShadowFilter();
    // var blurFilter1 = new PIXI.filters.SepiaFilter();
    // var blurFilter1 = new PIXI.filters.SmartBlurFilter();
    // var blurFilter1 = new PIXI.filters.CrossHatchFilter();  // *
    // var blurFilter1 = new PIXI.filters.TiltShiftFilter();
    // var blurFilter1 = new PIXI.filters.BlurDirFilter(0.5, 0.5);
    container.filters = [blurFilter1];



    var stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    document.body.appendChild( stats.domElement );



    requestAnimationFrame(animate);
}

function renderPoints () {

    g.clear();

    // for (var i = 0; i < fieldLines; i++) {
        var curve = points[0];
        g.lineStyle(2,0xffffff);
        g.moveTo(curve[0].x,curve[0].y);

        for (var j = 1; j < curve.length; j++) {
            // (0.3+(finalTemp/1000) * 0.0001) * 0xFFFFFF;
            g.lineStyle(1 * curve[j].size, 0x68b5c3);
            // g.lineStyle(2, (0.4+curve[j].size * 0.001) * 0xFFFFFF);
            g.lineTo(curve[j-1].x + (curve[j].x - curve[j-1].x)/2,curve[j-1].y + (curve[j].y - curve[j-1].y)/2);
            g.moveTo(curve[j].x,curve[j].y);
        };
    // }

    // var arrow =  PIXI.Sprite.fromImage('img/arrow.png');

    // for (var i = 1; i < points.length; i+=10) {
    //     g.beginFill(0xffffff);
    //     g.drawCircle(points[i].x,points[i].y,5);
    //     // g.drawImage(arrow, points[i].x,points[i].y);
    //     g.endFill();
    // };
}


function displayScore(){
  finalTemp = bisection();
  finalOut = calcScore(finalTemp);
}


function animate() {

    magVal = params.B;
    densVal = params.Dens;
    powVal = params.Pow;
    displayScore();
    var lastTime = Date.now();

    document.getElementById("temperature").value = ("TEMPERATURE: " + finalTemp);
    document.getElementById("console").value = ('Mag: ' + magVal + '\n' + 'Dens: ' + densVal + '\n' + 'Pow: ' + powVal + '\n\n' + 'Temp: ' + finalTemp  + '\n' + 'Score: ' + finalScore + '\n\n' + 'P_oh: ' + finalOut.P_oh * 1.e-6 + '\n' + 'P_alpha: ' + finalOut.P_alpha * 1.e-6 + '\n' + 'P_cond: ' + finalOut.P_cond * 1.e-6 + '\n' + 'P_rad: ' + finalOut.P_rad * 1.e-6 + '\n\n' + 'Beta thermal: ' + finalOut.beta_th + '\n' + 'Beta alpha: ' + finalOut.beta_falpha + '\n'+ 'Beta: ' + finalOut.beta + '\n' + 'Beta max: ' + finalOut.betamax + '\n\n' + 'Density: ' + finalOut.densreal*1.e-20 + '\n' + 'Dens_max: ' + finalOut.densmax*1.e-20 + '\n');

    Plasma.v = 1 + 3 * Params.Pow/1000;
    // iterate through the dudes and update their position
    for (var i = 0; i < aliens.length; i++)
    {
        var dude = aliens[i];
        dude.rotation = dude.direction;

        dude.phiRun += dude.w * params.tscale;
        // dude.phiRun %= Math.PI * 2;
        dude.phi = dude.phiRun + dude.phiStart;
        // dude.phi %= Math.PI * 2;

        // var normR =
        dude.R = Torus.R * plasmaPath(dude.phi, 0);
        // dude.scale.set(0.65+0.35*Math.sin((dude.phiRun+dude.phiStart)*2));
        dude.scale.set(0.8*plasmaPathScale(dude.phi, 0));
        dude.alpha = plasmaPathScale(dude.phi, Math.PI/8);
        // dude.alpha(0.5 + 0.5 * Math.pow( Math.sin( (dude.phi  - Math.PI/8) * 2), 2) );
        // dude.scale.set(0.6 + 0.4 * Math.cos( (dude.phiRun) * 2) );
        // dude.mesh.alpha = 0.5;
        // dude.globalAlpha = (0.5);

        dude.newPos.x = Math.cos(dude.phi) * dude.R * params.scale;
        dude.newPos.y = Math.sin(dude.phi) * dude.R * params.scale;
        var m = (dude.newPos.y - dude.oldPos.y) / (dude.newPos.x - dude.oldPos.x);
        var mPerp = - 1 / m;
        // if (Math.abs(mPerp) > 100 ) mPerp = dude.mPerp;
        mPerp = Math.abs(mPerp);
        dude.mPerp = mPerp;
        // var mPerp = -m;
        dude.m = m;

        // var m = plasmaPathN(dude.phi, dude.phiStart);
        // var mPerp = 1/m;
        if (Math.tan(dude.phi) > 0) mPerp *= -1;
        var norm = Math.sqrt(1/(1 + mPerp * mPerp));
        // document.getElementById("status").value = ("phi: " + dude.phi);

        dude.x = Math.round(dude.newPos.x + getRandomReal(-1,1) * powVal + dude.displ.x * (magVal-magMax)/magMax
                            + Math.sin(dude.phi * (5.0 + magVal) * 15.0) * LarmourRadius * norm);
                            // + Math.sin(lastTime/1000) * 5 * mPerp * norm);
        dude.y = Math.round(dude.newPos.y  + getRandomReal(-1,1) * powVal  + dude.displ.y * (magVal-magMax)/magMax
                            + Math.sin(dude.phi * (5.0 + magVal) * 15.0) * 5 * LarmourRadius * mPerp);
                            // + Math.sin(lastTime/1000) * 5 * mPerp * norm);
        // dude.tint = (0.7+Math.random() * 0.001) * 0xFFFFFF;

        dude.tint = (0.7+(finalTemp/1000) * 0.0001) * 0xFFFFFF;

        if ((params.highlightFieldLine === true) & (dude.group === 1))
            dude.tint = (0.3+(finalTemp/1000) * 0.0001) * 0xFFFFFF;
        if ((params.highlightBatch === true) & (dude.label === 'batch'))
            dude.tint = 0xFFFFFF;

        dude.oldPos.x = dude.newPos.x;
        dude.oldPos.y = dude.newPos.y;
        // dude.alpha = 0.1 + densVal / 10 * 0.7;
        // dude.alpha = i > aliens.length * densVal/10 ? 0 : 1;
        // dude.alpha = (Math.random() + densVal/10) > 1 ? 1 : 0;

    }

    // time to render the stage!
    renderer.render(stage);

    // request another animation frame...
    requestAnimationFrame(animate);
}
//==============================================================================
//                                     END
//==============================================================================

</script>

</body>

</html>